# Stack2

- 계산기 (Calculator)

    * 문자열 수식 계산법
        
        1. 중위표기법을 후위 표기법으로 변환
           
           - 입력 받은 중위 표기식에서 토큰을 읽는다.
           - 토큰이 피연산자이면 토큰을 출력
           - 토큰이 연산자인 경우, 토큰이 stack의 `top`에 저장되어 있는 연산자보다 우선순위가 높다면 스택에 `push`, 그렇지 않다면 stack의 `top`의 연산자 우선순위가 토큰의 우선순위보다 작을 때까지 stack에서 `pop`한 후 `push`한다.
           - 만약 `top`에 연산자가 없다면 `push`
           - 토큰이 오른쪽 괄호`)`라면 stack의 top에 왼쪽 괄호`(`가 올 때까지 스택에 `pop`을 수행
           - 중위표기식에 읽을 것이 없다면 종료
           - stack에 남은 연산자들을 모두 `pop` 
            
        2. 후위표기법의 수식을 스택을 이용하여 계산
        
        > 중위표기법 : 연산자를 피연산자의 가운데에 위치하는 방법
        >
        > 후위표기법 : 연산자를 피연산자의 뒤에 위치하는 방법  
        
- 백트래킹 (Backtrack)
    
    어떤 노드(Vertex)의 유망성을 점검한 후 유망하지 않다고 생각되면 그 노드의 부모로 되돌아가 다음 자식의 노드로 간다.
    
    > 유망성이란 해답의 경로가 될 수 있는 가능성을 의미
    ``
    백트래킹은 다음과 같은 절차로 진행된다.
    
    1. 상태 공간 트리의 깊이 우선 검색 실시
    2. 각 노드가 유망한지 검사
    3. 유망하지 않다면 해당 노드의 부모로 되돌아간다.
    4. 정답이 나올때까지 1-3번 반복
    
    > 백트래킹과 dfs와의 차이
    >
    > 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도를 줄이는 방법.
    >
    > `dfs`(깊이우선탐색)이 모든 경로를 추적하는데 반해 백트래킹은 불필요한 경로를 조기에 차단한다. (가지치기, prunning)

- 분할 정복 알고리즘 (Divide and Conquer)

    1. 분할 : 해결할 문제를 여러 개의 작은 부분으로 나눔
    2. 정복 : 나눈 작은 문제를 각각 해결
    3. 통합 : (필요하다면) 해결된 해답을 모은다.
    
    이와 같이 분할 정복 알고리즘을 사용하는 대표적인 알고리즘이 merge-sort(병합정렬), quick-sort(퀵정렬)이 있다.
    
- 퀵 소트 (Quick sort)

    주어진 배열을 두 개로 분할하고 각각을 정렬하는 알고리즘
